<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="turbo-cache-control" content="no-cache">

    <!-- Primary Meta Tags -->
    <title>Optimizing Windows Function Resolving: A Case Study Into GetProcAddress - phasetw0</title>
    <meta name="title" content="Optimizing Windows Function Resolving: A Case Study Into GetProcAddress - phasetw0">
    <meta name="description" content="It was a cold winter morning. hypervis0r had just woken up at 1 AM because his sleep schedule was royally fucked, and he hopped onto the private..." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://phasetw0.com/windows-internals/optimizing_function_resolving/">
    <meta property="og:title" content="Optimizing Windows Function Resolving: A Case Study Into GetProcAddress - phasetw0">
    <meta property="og:description" content="It was a cold winter morning. hypervis0r had just woken up at 1 AM because his sleep schedule was royally fucked, and he hopped onto the private...">
    <meta property="og:image" content="https://phasetw0.com/windows-internals/assets/direct_call_imports.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://phasetw0.com/windows-internals/optimizing_function_resolving/">
    <meta property="twitter:title" content="Optimizing Windows Function Resolving: A Case Study Into GetProcAddress - phasetw0">
    <meta property="twitter:description" content="It was a cold winter morning. hypervis0r had just woken up at 1 AM because his sleep schedule was royally fucked, and he hopped onto the private...">
    <meta property="twitter:image" content="https://phasetw0.com/windows-internals/assets/direct_call_imports.png">
    
    <script>(function () { var el = document.documentElement, m = localStorage.getItem("doc_theme"), wm = window.matchMedia; if (m === "dark" || (!m && wm && wm("(prefers-color-scheme: dark)").matches)) { el.classList.add("dark") } else { el.classList.remove("dark") } })();</script>

    <link href="/assets/logo.png" rel="icon" />
    <link href="/resources/css/retype.css?v=1.11.2.694528138297" rel="stylesheet" data-turbo-track="reload" />

    <script type="text/javascript" src="/resources/js/config.js?v=1.11.2.694528138297" defer data-turbo-track="reload"></script>
    <script type="text/javascript" src="/resources/js/retype.js?v=1.11.2" defer data-turbo-track="reload"></script>
    <script id="lunr-js" type="text/javascript" src="/resources/js/lunr.js?v=1.11.2.694528138297" defer></script>
    <script id="prism-js" type="text/javascript" src="/resources/js/prism.js?v=1.11.2.694528138297" defer></script>
</head>
    <body>
        <div id="docs-app" class="relative text-base antialiased text-gray-700 bg-white font-body dark:bg-dark-850 dark:text-dark-300">
    <div class="absolute bottom-0 left-0 bg-gray-100 dark:bg-dark-800" style="top: 5rem; right: 50%"></div>

    <header id="docs-site-header" class="sticky top-0 z-30 flex w-full h-16 bg-white border-b border-gray-200 md:h-20 dark:bg-dark-850 dark:border-dark-650">
    <div class="container relative flex items-center justify-between flex-grow pr-6 md:justify-start">
        <!-- Mobile menu button skeleton -->
        <button v-cloak class="skeleton docs-mobile-menu-button flex items-center justify-center flex-shrink-0 overflow-hidden dark:text-white focus:outline-none rounded-full w-10 h-10 ml-3.5 md:hidden"><svg xmlns="http://www.w3.org/2000/svg" class="mb-px flex-shrink-0" width="24" height="24" viewBox="0 0 24 24" role="presentation" style="margin-bottom: 0px;"><g fill="currentColor"><path d="M2 4h20v2H2zM2 11h20v2H2zM2 18h20v2H2z"></path></g></svg></button>
        <div v-cloak id="docs-sidebar-toggle"></div>

        <!-- Logo -->
        <div class="flex items-center justify-between h-full py-2 md:w-75">
            <div class="flex items-center px-2 md:px-6">
                <a id="docs-site-logo" href="/" class="flex items-center leading-snug text-2xl">
                    <span class="w-10 mr-2 flex-grow-0 flex-shrink-0 overflow-hidden">
                        <img class="max-h-10 dark:hidden md:inline-block" src="/assets/logo.png">
                        <img class="max-h-10 hidden dark:inline-block" src="/assets/logo.png">
                    </span>
                    <span class="dark:text-white font-semibold line-clamp-1 md:line-clamp-2">phasetw0</span>
                </a>
            </div>

            <span class="hidden h-8 border-r md:inline-block dark:border-dark-650"></span>
        </div>

        <div class="flex justify-between md:flex-grow">
            <!-- Top Nav -->
            <nav class="hidden md:flex">
    <ul class="flex flex-col mb-4 md:pl-16 md:mb-0 md:flex-row md:items-center">
        <li class="md:mr-6">
            <a class="block py-2 text-sm text-gray-400 whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 md:mb-0" href="https://github.com/ph4s3tw0">GitHub</a>
        </li>
        <li class="md:mr-6">
            <a class="block py-2 text-sm text-gray-400 whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 md:mb-0" href="https://www.hackthebox.eu/home/teams/profile/4088">HackTheBox</a>
        </li>
        <li class="md:mr-6">
            <a class="block py-2 text-sm text-gray-400 whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 md:mb-0" href="https://ctftime.org/team/133618">CTFTime</a>
        </li>
    </ul>
</nav>

            <!-- Header Right Skeleton -->
            <div v-cloak class="flex justify-end flex-grow skeleton">

                <!-- Search input mock -->
                <div class="relative hidden w-40 lg:block lg:max-w-sm lg:ml-auto">
                    <div class="absolute flex items-center justify-center h-full pl-3 dark:text-dark-300">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon-base" width="16" height="16" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation"  style="margin-bottom: 1px;"><g fill="currentColor" ><path d="M21.71 20.29l-3.68-3.68A8.963 8.963 0 0020 11c0-4.96-4.04-9-9-9s-9 4.04-9 9 4.04 9 9 9c2.12 0 4.07-.74 5.61-1.97l3.68 3.68c.2.19.45.29.71.29s.51-.1.71-.29c.39-.39.39-1.03 0-1.42zM4 11c0-3.86 3.14-7 7-7s7 3.14 7 7c0 1.92-.78 3.66-2.04 4.93-.01.01-.02.01-.02.01-.01.01-.01.01-.01.02A6.98 6.98 0 0111 18c-3.86 0-7-3.14-7-7z" ></path></g></svg>
                    </div>

                    <input class="w-full h-10 transition-colors duration-200 ease-in bg-gray-200 border border-transparent rounded md:text-sm hover:bg-white hover:border-gray-300 focus:outline-none focus:bg-white focus:border-gray-500 dark:bg-dark-600 dark:border-dark-600 placeholder-gray-400 dark:placeholder-dark-400"
                    style="padding: 0.625rem 0.75rem 0.625rem 2rem" type="text" placeholder="Search" />
                </div>

                <!-- Mobile search button mock -->
                <div class="flex items-center justify-center w-10 h-10 lg:hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" class="flex-shrink-0 icon-base" width="20" height="20" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation"  style="margin-bottom: 0px;"><g fill="currentColor" ><path d="M21.71 20.29l-3.68-3.68A8.963 8.963 0 0020 11c0-4.96-4.04-9-9-9s-9 4.04-9 9 4.04 9 9 9c2.12 0 4.07-.74 5.61-1.97l3.68 3.68c.2.19.45.29.71.29s.51-.1.71-.29c.39-.39.39-1.03 0-1.42zM4 11c0-3.86 3.14-7 7-7s7 3.14 7 7c0 1.92-.78 3.66-2.04 4.93-.01.01-.02.01-.02.01-.01.01-.01.01-.01.02A6.98 6.98 0 0111 18c-3.86 0-7-3.14-7-7z" ></path></g></svg>
                </div>

                <!-- Dark mode switch placehokder -->
                <div class="w-10 h-10 lg:ml-2"></div>

                <!-- History button mock -->
                <div class="flex items-center justify-center w-10 h-10" style="margin-right: -0.625rem;">
                    <svg xmlns="http://www.w3.org/2000/svg" class="flex-shrink-0 icon-base" width="22" height="22" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation"  style="margin-bottom: 0px;"><g fill="currentColor" ><g ><path d="M12.01 6.01c-.55 0-1 .45-1 1V12a1 1 0 00.4.8l3 2.22a.985.985 0 001.39-.2.996.996 0 00-.21-1.4l-2.6-1.92V7.01c.02-.55-.43-1-.98-1z"></path><path d="M12.01 1.91c-5.33 0-9.69 4.16-10.05 9.4l-.29-.26a.997.997 0 10-1.34 1.48l1.97 1.79c.19.17.43.26.67.26s.48-.09.67-.26l1.97-1.79a.997.997 0 10-1.34-1.48l-.31.28c.34-4.14 3.82-7.41 8.05-7.41 4.46 0 8.08 3.63 8.08 8.09s-3.63 8.08-8.08 8.08c-2.18 0-4.22-.85-5.75-2.4a.996.996 0 10-1.42 1.4 10.02 10.02 0 007.17 2.99c5.56 0 10.08-4.52 10.08-10.08.01-5.56-4.52-10.09-10.08-10.09z"></path></g></g></svg>
                </div>
            </div>

            <div v-cloak class="flex items-center justify-end flex-grow">
                <div id="docs-mobile-search-button"></div>
                <doc-search-desktop></doc-search-desktop>

                <doc-theme-switch class="lg:ml-2"></doc-theme-switch>
                <doc-history></doc-history>
            </div>
        </div>
    </div>
</header>


    <div class="container relative flex bg-white">
        <!-- Sidebar Skeleton -->
<div v-cloak class="fixed flex flex-col flex-shrink-0 duration-300 ease-in-out bg-gray-100 border-gray-200 sidebar top-20 w-75 border-r h-screen md:sticky transition-transform skeleton dark:bg-dark-800 dark:border-dark-650">

    <!-- Render this div, if config.showSidebarFilter is `true` -->
    <div class="flex items-center h-16 px-6">
        <input class="w-full h-8 px-3 py-2 transition-colors duration-200 ease-linear bg-white border border-gray-200 rounded shadow-none text-sm focus:outline-none focus:border-gray-600 dark:bg-dark-600 dark:border-dark-600" type="text" placeholder="Filter" />
    </div>

    <div class="pl-6 mb-4 mt-1">
        <div class="w-32 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
        <div class="w-48 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
        <div class="w-40 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
        <div class="w-32 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
        <div class="w-48 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
        <div class="w-40 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
    </div>


    <div class="flex-shrink-0 mt-auto bg-transparent dark:border-dark-650">
        <a
    class="flex items-center justify-center flex-nowrap h-16 text-gray-400 dark:text-dark-400 hover:text-gray-700 dark:hover:text-dark-300 transition-colors duration-150 ease-in docs-powered-by"
    target="_blank"
    href="https://retype.com/"
    rel="noopener"
>
    <span class="text-xs whitespace-nowrap">Powered by</span>
    <svg xmlns="http://www.w3.org/2000/svg" class="ml-2" fill="currentColor" width="96" height="20" overflow="visible"><path d="M0 0v20h13.59V0H0zm11.15 17.54H2.44V2.46h8.71v15.08zM15.8 20h2.44V4.67L15.8 2.22zM20.45 6.89V20h2.44V9.34z"/><g><path d="M40.16 8.44c0 1.49-.59 2.45-1.75 2.88l2.34 3.32h-2.53l-2.04-2.96h-1.43v2.96h-2.06V5.36h3.5c1.43 0 2.46.24 3.07.73s.9 1.27.9 2.35zm-2.48 1.1c.26-.23.38-.59.38-1.09 0-.5-.13-.84-.4-1.03s-.73-.28-1.39-.28h-1.54v2.75h1.5c.72 0 1.2-.12 1.45-.35zM51.56 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92h4.74v1.83h-6.79V5.36h6.64zM60.09 7.15v7.48h-2.06V7.15h-2.61V5.36h7.28v1.79h-2.61zM70.81 14.64h-2.06v-3.66l-3.19-5.61h2.23l1.99 3.45 1.99-3.45H74l-3.19 5.61v3.66zM83.99 6.19c.65.55.97 1.4.97 2.55s-.33 1.98-1 2.51-1.68.8-3.04.8h-1.23v2.59h-2.06V5.36h3.26c1.42 0 2.45.28 3.1.83zm-1.51 3.65c.25-.28.37-.69.37-1.22s-.16-.92-.48-1.14c-.32-.23-.82-.34-1.5-.34H79.7v3.12h1.38c.68 0 1.15-.14 1.4-.42zM95.85 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92H96v1.83h-6.79V5.36h6.64z"/></g></svg>
</a>

    </div>
</div>

<!-- Sidebar component -->
<doc-sidebar v-cloak>
    <template #sidebar-footer>
        <div
            class="flex-shrink-0 mt-auto border-t md:bg-transparent md:border-none dark:border-dark-650"
        >

            <div class="py-3 px-6 md:hidden border-b dark:border-dark-650">
                <nav>
                    <ul class="flex flex-wrap justify-center items-center">
                        <li class="mr-6">
                            <a class="block py-1 text-sm whitespace-nowrap transition-colors duration-200 ease-linear text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://github.com/ph4s3tw0">GitHub</a>
                        </li>
                        <li class="mr-6">
                            <a class="block py-1 text-sm whitespace-nowrap transition-colors duration-200 ease-linear text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://www.hackthebox.eu/home/teams/profile/4088">HackTheBox</a>
                        </li>
                        <li class="mr-6">
                            <a class="block py-1 text-sm whitespace-nowrap transition-colors duration-200 ease-linear text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://ctftime.org/team/133618">CTFTime</a>
                        </li>
                    </ul>
                </nav>
            </div>


            <a
    class="flex items-center justify-center flex-nowrap h-16 text-gray-400 dark:text-dark-400 hover:text-gray-700 dark:hover:text-dark-300 transition-colors duration-150 ease-in docs-powered-by"
    target="_blank"
    href="https://retype.com/"
    rel="noopener"
>
    <span class="text-xs whitespace-nowrap">Powered by</span>
    <svg xmlns="http://www.w3.org/2000/svg" class="ml-2" fill="currentColor" width="96" height="20" overflow="visible"><path d="M0 0v20h13.59V0H0zm11.15 17.54H2.44V2.46h8.71v15.08zM15.8 20h2.44V4.67L15.8 2.22zM20.45 6.89V20h2.44V9.34z"/><g><path d="M40.16 8.44c0 1.49-.59 2.45-1.75 2.88l2.34 3.32h-2.53l-2.04-2.96h-1.43v2.96h-2.06V5.36h3.5c1.43 0 2.46.24 3.07.73s.9 1.27.9 2.35zm-2.48 1.1c.26-.23.38-.59.38-1.09 0-.5-.13-.84-.4-1.03s-.73-.28-1.39-.28h-1.54v2.75h1.5c.72 0 1.2-.12 1.45-.35zM51.56 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92h4.74v1.83h-6.79V5.36h6.64zM60.09 7.15v7.48h-2.06V7.15h-2.61V5.36h7.28v1.79h-2.61zM70.81 14.64h-2.06v-3.66l-3.19-5.61h2.23l1.99 3.45 1.99-3.45H74l-3.19 5.61v3.66zM83.99 6.19c.65.55.97 1.4.97 2.55s-.33 1.98-1 2.51-1.68.8-3.04.8h-1.23v2.59h-2.06V5.36h3.26c1.42 0 2.45.28 3.1.83zm-1.51 3.65c.25-.28.37-.69.37-1.22s-.16-.92-.48-1.14c-.32-.23-.82-.34-1.5-.34H79.7v3.12h1.38c.68 0 1.15-.14 1.4-.42zM95.85 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92H96v1.83h-6.79V5.36h6.64z"/></g></svg>
</a>

        </div>
    </template>
</doc-sidebar>


        <div class="flex-grow min-w-0 dark:bg-dark-850">
            <!-- Render "toolbar" template here on api pages --><!-- Render page content -->
            <div class="flex">
    <div class="flex-grow min-w-0 px-6 md:px-16">
        <main class="relative pt-6 pb-16">
            <div class="docs-markdown" id="docs-content">
                <!-- Rendered if sidebar right is enabled -->
                <div id="docs-sidebar-right-toggle"></div>
               
                <!-- Page content  -->
<doc-anchor-target id="optimizing-windows-function-resolving-a-case-study-into-getprocaddress" class="break-words">
    <h1>
        <doc-anchor-trigger class="header-anchor-trigger" to="#optimizing-windows-function-resolving-a-case-study-into-getprocaddress">#</doc-anchor-trigger>
        <span>Optimizing Windows Function Resolving: A Case Study Into GetProcAddress</span>
    </h1>
</doc-anchor-target>
<doc-anchor-target id="written-by-hypervis0r-and-jeff">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#written-by-hypervis0r-and-jeff">#</doc-anchor-trigger>
        <span>Written by <a href="https://twitter.com/hypervis0r">hypervis0r</a> and <a href="https://twitter.com/Jeffsepticeye2">Jeff</a></span>
    </h4>
</doc-anchor-target>
<doc-anchor-target id="introduction">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#introduction">#</doc-anchor-trigger>
        <span>Introduction</span>
    </h2>
</doc-anchor-target>
<p>It was a cold winter morning. hypervis0r had just woken up at 1 AM because his sleep schedule was royally fucked, and he hopped onto the private phasetw0 discord server. In there, he noticed Jeff and base64 discussing the feasibility of running a binary search on the export data directory of a PE file in order to resolve functions.</p>
<p>hypervis0r, who is in love with hash tables, suggested an obvious solution for optimizing <code v-pre>GetProcAddress</code>; generating a hash table from a loaded DLL and using the hash table for constant-time lookup speeds. Base64, who feels the compulsive need to disagree with everything hypervis0r says, suggested that brute force lookup would probably be faster, and compelled him to run a benchmark. hypervis0r never turns down a challenge, so he decided to spend the next 8 hours of his life running tests.</p>
<p>Eight hours later, both hypervis0r and Jeff had programmed some basic implementations of <code v-pre>GetProcAddress</code> and battled them to the death with benchmarks. Spoiler alert, hypervis0r&#x27;s implementation was the fastest (it always is), and he felt the need to compile this all into a blog post for the masses.</p>
<p>This article is not gonna cover anything in depth, since it was meant to just show the benchmarks of some methods Jeff and hypervis0r implemented. It&#x27;s only going to briefly cover the concepts needed to understand the content of this article, along with providing links to some in-depth resources.</p>
<doc-anchor-target id="how-does-getprocaddress-work">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#how-does-getprocaddress-work">#</doc-anchor-trigger>
        <span>How does GetProcAddress work?</span>
    </h2>
</doc-anchor-target>
<p>For the uninitiated, all executable files on Windows contain an array of imported and exported functions stored inside the Portable Executable (PE) file format.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">#include &lt;stdio.h&gt;

int main(void)
{
	puts(&quot;ma name jeff&quot;);
	return 0;
}</code></pre>
</doc-codeblock></div>
<p>If you are a C/C++ developer, you now that <code v-pre>puts</code> is not a function that you write yourself, but rather one you can magically call. This is possible through the use of <a href="https://en.wikipedia.org/wiki/Dynamic-link_library">Dynamic-Link Libraries, or DLLs</a>.</p>
<p>There are many DLLs, in this case <code v-pre>msvcrt.dll</code>, which have certain functions already compiled and exported (e.g. can be used by other programs). In this example, when your executable is loaded by Windows, the kernel will load <code v-pre>msvcrt.dll</code> into the address space of your new process, and the Import Address Table (IAT) of your executable will be updated with the virtual address of the exported function, in this case <code v-pre>puts</code>.</p>
<p>Take the following code, for instance.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">#include &lt;windows.h&gt;

int main(void)
{
	MessageBoxA(NULL, &quot;calling MessageBoxA directly&quot;, &quot;kek&quot;, MB_OK);
	return 0;
}</code></pre>
</doc-codeblock></div>
<p>If you compile this code and open the executable in PE-bear (or any other PE file explorer), you will notice <code v-pre>MessageBoxA</code> among the imports of this program. If you were to open up the containing module in a PE file explorer, you would find <code v-pre>MessageBoxA</code> located in the list of exported functions.</p>
<p><figure class="content-center">
    <img src="../assets/direct_call_imports.png" alt="Imported functions located in the IAT" title="Imported functions located in the IAT" />
    <figcaption class="caption">Imported functions located in the IAT</figcaption>
</figure>
</p>
<p>This works because the Windows executable loader can read the IAT of the loaded executable, load <code v-pre>user32.dll</code> into the process address space, and update the virtual address for the import entry. When <code v-pre>MessageBoxA</code> gets called, the instruction pointer will get set to the updated virtual address in the IAT.</p>
<p>In addition to loadtime function resolving, functions can also be resolved dynamically during runtime. Take the following code, for example.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">#include &lt;windows.h&gt;

typedef int(WINAPI *_MessageBoxA)(HWND, LPCSTR, LPCSTR, UINT);

int main(void)
{
	HMODULE hUser32 = LoadLibrary(&quot;User32.dll&quot;);
	_MessageBoxA MyMessageBoxA = (_MessageBoxA)GetProcAddress(hUser32, &quot;MessageBoxA&quot;);
	if (!MyMessageBoxA)
    {
		return -1;
	}

	MyMessageBoxA(NULL, &quot;calling MessageBoxA undirectly&quot;, &quot;kek&quot;, MB_OK);

	return 0;
}</code></pre>
</doc-codeblock></div>
<p>This code does the exact same thing as the previous example. However, if you compile and examine the executable with a PE file explorer, you will find that there is no reference to <code v-pre>MessageBoxA</code> or <code v-pre>User32.dll</code> in the IAT.</p>
<p><figure class="content-center">
    <img src="../assets/undirect_call_imports.png" alt="MessageBoxA no longer found in IAT" title="MessageBoxA no longer found in IAT" />
    <figcaption class="caption">MessageBoxA no longer found in IAT</figcaption>
</figure>
</p>
<p>This is standard behavior, as the program is not directly calling any functions from that DLL. As a result, there is no reason for it to be loaded by the Windows executable loader at loadtime. In this case, the program is manually loading <code v-pre>User32.dll</code> at runtime using <code v-pre>LoadLibrary</code>, finding the address of the function it needs using <code v-pre>GetProcAddress</code>, then calling it via a function pointer.</p>
<p>In essence, <code v-pre>GetProcAddress</code> walks through a table found in DLLs known as the export directory table to find the relative virtual address (RVA; relative to the DLL base address) of a function. This table contains the names and RVAs of every exported function in a PE file, and is used to resolve exported function locations easily. For more in-depth information, refer to <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-edata-section-image-only">the MSDN page on the PE format</a>.</p>
<p>Using dynamic function resolution has the advantage of removing what functions you&#x27;re intending to call from the IAT. For example, let&#x27;s take a basic shellcode injection. The usual implementation of it follows the pattern <code v-pre>OpenProcess -&gt; VirtualAllocEx -&gt; WriteProcessMemory -&gt; CreateRemoteThread -&gt; WaitForSingleObject</code>, so whenever you see these functions in the IAT, you can be reasonably sure that there is some kind of injection happening. By dynamically resolving functions at runtime, you can remove those patterns from your executable import table.</p>
<p>There is one key thing to note however; if you take another look at the above picture, you&#x27;ll find that the executable now has two additional imports from <code v-pre>kernel32.dll</code>, <code v-pre>LoadLibraryA</code> and <code v-pre>GetProcAddress</code>. You wouldn&#x27;t know what functions are being called, however if you were experienced in reverse-engineering, you would know that dynamic function analysis is being used somehow. Knowing this, one could simply disassemble the function where <code v-pre>GetProcAddress</code> was called to find the resolved function.</p>
<p>For pretty obvious reasons, we didn&#x27;t want <code v-pre>GetProcAddress</code> to appear in our imports, nor to get hooked somehow. The relatively simple solution was to make an implementation which manually parses the loaded DLLs to get the address of the function you want, without calling any external Windows API function. As it turns out, with a bit of knowledge about the <a href="https://blog.kowalczyk.info/articles/pefileformat.html">PE file format</a> you can easily do it; however after reviewing several code repositories on GitHub, we noticed that a lot of them had a similar implementation, which is an (almost) identical inline assembly block (it&#x27;s almost like they&#x27;re are copy-pasting it or something!)</p>
<p>Simply rewriting <code v-pre>GetProcAddress</code> is no fun, we are computer scientists after all. To recount the introduction, hypervis0r and Jeff were curious to see if the <code v-pre>GetProcAddress</code> implementation could be potentially optimized for maximum speed and efficiency. As a result, we drew up a few different implementations and benchmarked each to determine if <code v-pre>GetProcAddress</code> could be faster in any such way.</p>
<p>To run our benchmarks, we decided to use Google&#x27;s <a href="https://github.com/google/benchmark"><code v-pre>benchmark</code></a> library, written in C++. This library takes accurate measurements down to the nanosecond, and runs thousands of iterations to ensure a stable result. Along with <code v-pre>benchmark</code>, we decided to test against <code v-pre>ntdll.dll</code>, as it contains thousands of exports with different names.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">/*
	Exported function names located in different
	positions in the export directory.
*/
std::array&lt;const char*, 21&gt; func_names = {
   &quot;A_SHAFinal&quot;,
   &quot;CsrAllocateCaptureBuffer&quot;,
   &quot;DbgBreakPoint&quot;,
   &quot;EtwProcessPrivateLoggerRequest&quot;,
   &quot;KiRaiseUserExceptionDispatcher&quot;,
   &quot;LdrAccessResource&quot;,
   &quot;MD4Final&quot;,
   &quot;_wcsnset_s&quot;,
   &quot;abs&quot;,
   &quot;bsearch&quot;,
   &quot;ceil&quot;,
   &quot;fabs&quot;,
   &quot;iswctype&quot;,
   &quot;labs&quot;,
   &quot;mbstowcs&quot;,
   &quot;pow&quot;,
   &quot;qsort&quot;,
   &quot;sin&quot;,
   &quot;tan&quot;,
   &quot;vDbgPrintEx&quot;,
   &quot;wcscat&quot; };</code></pre>
</doc-codeblock></div>
<doc-anchor-target id="case-1-stock-getprocaddress">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#case-1-stock-getprocaddress">#</doc-anchor-trigger>
        <span>Case 1: Stock GetProcAddress</span>
    </h2>
</doc-anchor-target>
<doc-anchor-target id="written-by-hypervis0r">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#written-by-hypervis0r">#</doc-anchor-trigger>
        <span>Written by hypervis0r</span>
    </h4>
</doc-anchor-target>
<p>To start things off, we needed a control benchmark to determine whether a case performs better or worse. For this, we just run <code v-pre>GetProcAddress</code> with our list of functions from <code v-pre>ntdll.dll</code>. As expected, it performed moderately well in terms of the other techniques we tested. I suspect the reason why <code v-pre>GetProcAddress</code> is faster than most other custom implementations is due to the fact that there are some fancy tricks to optimize function resolving, such as <a href="https://devblogs.microsoft.com/oldnewthing/20100317-00/?p=14573">import hinting</a> and <a href="https://devblogs.microsoft.com/oldnewthing/20100318-00/?p=14563">import binding</a>.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">/* 
    /favor:AMD64 /arch:AVX2
    Written by hypervis0r
*/
void BM_GetProcAddress(benchmark::State&amp; state)
{
	HMODULE hNtdll = LoadLibraryA(&quot;ntdll.dll&quot;);

	FARPROC func = NULL;

	/*
    	Start the benchmark
    */
	for (auto _ : state)
	{
		for (int i = 0; i &lt; func_names.size(); i++)
		{
			func = GetProcAddress(hNtdll, func_names[i]);
			if (!func)
			{
				printf(&quot;[-] Failed to find exported function\n&quot;);
				exit(-1);
			}
		}
	}
}
BENCHMARK(BM_GetProcAddress);</code></pre>
</doc-codeblock></div>
<doc-anchor-target id="results">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#results">#</doc-anchor-trigger>
        <span>Results</span>
    </h3>
</doc-anchor-target>
<p><strong>Time Complexity</strong>: O(n)</p>
<p><strong>Space Complexity</strong>: O(1)</p>
<p><strong>Benchmark Results</strong>: ~= 3519 ns</p>
<doc-anchor-target id="case-2-custom-brute-force-hash-search">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#case-2-custom-brute-force-hash-search">#</doc-anchor-trigger>
        <span>Case 2: Custom Brute Force Hash Search</span>
    </h2>
</doc-anchor-target>
<doc-anchor-target id="written-by-hypervis0r-1">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#written-by-hypervis0r-1">#</doc-anchor-trigger>
        <span>Written by hypervis0r</span>
    </h4>
</doc-anchor-target>
<p>Next, we wanted to test and see how efficient a brute force search was in the context of API hashing. This function just iterates through each entry in the export directory, hashes the function name, and compares it to the input hash. This function turned out to be the slowest out of all the cases, most likely due to the fact that my <code v-pre>djb2</code> hash function was not as optimized as <code v-pre>strcmp</code>.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">/* 
    /favor:AMD64 /arch:AVX2
    Written by hypervis0r
*/
void* GetProcAddress_BruteHash(PVOID pModuleBase, uint64_t djb2_hash)
{
	// Get DOS header
	PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;
	if (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)
		return NULL;

	// Get NT headers
	PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-&gt;e_lfanew);
	if (pImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE)
		return NULL;

	// Get the EAT
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);

	PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfFunctions);
	PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNames);
	PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNameOrdinals);

	for (WORD cx = 0; cx &lt; pImageExportDirectory-&gt;NumberOfNames; cx++) {
		PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]);
		PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];

		if (hash_string_djb2(pczFunctionName) == djb2_hash)
			return pFunctionAddress;
	}

	return NULL;
}

void BM_Brute(benchmark::State&amp; state)
{
	HMODULE hNtdll = LoadLibraryA(&quot;ntdll.dll&quot;);

	void* func = NULL;

	for (auto _ : state)
	{
		for (int i = 0; i &lt; djb2_list.size(); i++)
		{
			func = GetProcAddress_BruteHash(hNtdll, djb2_list[i]);
			if (!func)
			{
				printf(&quot;[-] Failed to find exported function\n&quot;);
				exit(-1);
			}
		}
	}
}
BENCHMARK(BM_Brute);</code></pre>
</doc-codeblock></div>
<doc-anchor-target id="results-1">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#results-1">#</doc-anchor-trigger>
        <span>Results</span>
    </h3>
</doc-anchor-target>
<p><strong>Time Complexity</strong>: O(n)</p>
<p><strong>Space Complexity</strong>: O(1)</p>
<p><strong>Benchmark Results</strong>:  ~= 989553 ns (247x slower than <code v-pre>GetProcAddress</code>)</p>
<doc-anchor-target id="case-3-runtime-generated-hash-table">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#case-3-runtime-generated-hash-table">#</doc-anchor-trigger>
        <span>Case 3: Runtime-Generated Hash Table</span>
    </h2>
</doc-anchor-target>
<doc-anchor-target id="written-by-hypervis0r-2">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#written-by-hypervis0r-2">#</doc-anchor-trigger>
        <span>Written by hypervis0r</span>
    </h4>
</doc-anchor-target>
<p>For this test, I considered the possibility of generating a hash table containing all of the exported entries. At the time of writing this function, I was certain this function would be the fastest, as theoretically the time complexity was O(1) at its best. Base64 seemed to disagree with me, so to prove him wrong, I wrote up a hash table implementation with linked list chaining.</p>
<p>To my surprise, generating a hash table at runtime was <em>slower</em> than stock <code v-pre>GetProcAddress</code>. In shock, I ran the Visual Studio profiler to determine the cause of such speed loss. Of course, I had forgotten how slow the heap was, and most of the execution time of the program was spent inside of <code v-pre>malloc</code> and <code v-pre>free</code>.</p>
<p>Running the benchmarks, without including the hash table generation or freeing, showed that the hash table lookup was around 5x faster than <code v-pre>GetProcAddress</code>. With this knowledge, I was inspired to pre-generate the hash table and to embed it directly into the PE file, which will be elaborated on in Case 6.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">/* 
    /favor:AMD64 /arch:AVX2
    Written by hypervis0r
*/
struct hash_table_const* GenerateHashTableFromExports(PVOID pModuleBase)
{
	// Get DOS header
	PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;
	if (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)
		return NULL;

	// Get NT headers
	PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-&gt;e_lfanew);
	if (pImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE)
		return NULL;

	// Get the EAT
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);

	PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfFunctions);
	PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNames);
	PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNameOrdinals);

	/*
    	struct hash_table_const is an optimized hash table implementation
        that uses a single contiguous block of memory for all of the items.
    */
	struct hash_table_const* table = create_hash_table_const(pImageExportDirectory-&gt;NumberOfNames);

	for (WORD cx = 0; cx &lt; pImageExportDirectory-&gt;NumberOfNames; cx++) {
		PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]);
		PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];

		struct hash_table_item* item = create_hash_const_item(table, hash_string_djb2(pczFunctionName), pFunctionAddress);

		hash_table_insert(table, item);
	}

	return table;
}

void BM_GenHashTable(benchmark::State&amp; state)
{
	HMODULE hNtdll = LoadLibraryA(&quot;ntdll.dll&quot;);

	void* func = NULL;

	for (auto _ : state)
	{
		struct hash_table_const* table = GenerateHashTableFromExports(hNtdll);

		for (int i = 0; i &lt; func_names.size(); i++)
		{
			func = hash_table_search((struct hash_table*)table, hash_string_djb2(func_names[i]));
			if (!func)
			{
				printf(&quot;[-] FUCK&quot;);
				exit(-1);
			}
		}

		free_hash_table_const(table);
	}
}
BENCHMARK(BM_GenHashTable);</code></pre>
</doc-codeblock></div>
<doc-anchor-target id="results-2">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#results-2">#</doc-anchor-trigger>
        <span>Results</span>
    </h3>
</doc-anchor-target>
<p><strong>Time Complexity</strong>: O(1) on average; O(n) worst case</p>
<p><strong>Space Complexity</strong>: O(n)</p>
<p><strong>Benchmark Results</strong>: ~= 90039 ns (22x slower than <code v-pre>GetProcAddress</code>)</p>
<doc-anchor-target id="case-4-runtime-generated-stdunordered_map">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#case-4-runtime-generated-stdunordered_map">#</doc-anchor-trigger>
        <span>Case 4: Runtime-Generated <code v-pre>std::unordered_map</code></span>
    </h2>
</doc-anchor-target>
<doc-anchor-target id="written-by-hypervis0r-3">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#written-by-hypervis0r-3">#</doc-anchor-trigger>
        <span>Written by hypervis0r</span>
    </h4>
</doc-anchor-target>
<p>Base64, who is in love with all things C++, wanted to see if <code v-pre>std::unordered_map</code> was faster than my shitty hash table implementation, so I gave him the benefit of the doubt and tested it. While <code v-pre>std::unordered_map</code> was faster than the brute force hash search, it was still slower than my hash table implementation, because the STL is shit.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">/* 
    /favor:AMD64 /arch:AVX2
    Written by hypervis0r
*/
std::unordered_map &lt;uint64_t, void*&gt; GetUnorderedMapFromExports(PVOID pModuleBase)
{
	std::unordered_map &lt;uint64_t, void*&gt; map = {};

	// Get DOS header
	PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;
	if (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)
		return map;

	// Get NT headers
	PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-&gt;e_lfanew);
	if (pImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE)
		return map;

	// Get the EAT
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);

	PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfFunctions);
	PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNames);
	PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNameOrdinals);

    // Reserve space in the unordered map
	map.reserve(pImageExportDirectory-&gt;NumberOfNames);

	for (WORD cx = 0; cx &lt; pImageExportDirectory-&gt;NumberOfNames; cx++) {
		PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]);
		PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];

		map.emplace(hash_string_djb2(pczFunctionName), pFunctionAddress);
	}

	return map;
}

void BM_UnorderedMap(benchmark::State&amp; state)
{
	HMODULE hNtdll = LoadLibraryA(&quot;ntdll.dll&quot;);

	void* func = NULL;

	for (auto _ : state)
	{
		auto map = GetUnorderedMapFromExports(hNtdll);

		for (int i = 0; i &lt; func_names.size(); i++)
		{
			try
			{
				func = map.at(hash_string_djb2(func_names[i]));
			}
			catch (const std::exception&amp; e)
			{
				printf(&quot;[-] Failed to find exported function\n %s\n&quot;, e.what());
				exit(-1);
			}
		}
	}
}
BENCHMARK(BM_UnorderedMap);</code></pre>
</doc-codeblock></div>
<doc-anchor-target id="results-3">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#results-3">#</doc-anchor-trigger>
        <span>Results</span>
    </h3>
</doc-anchor-target>
<p><strong>Time Complexity</strong>: O(1) on average; O(n) worst case</p>
<p><strong>Space Complexity</strong>: O(n)</p>
<p><strong>Benchmark Results</strong>: ~= 354985 ns (88x slower than <code v-pre>GetProcAddress</code>)</p>
<doc-anchor-target id="case-5-binary-search">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#case-5-binary-search">#</doc-anchor-trigger>
        <span>Case 5: Binary Search</span>
    </h2>
</doc-anchor-target>
<doc-anchor-target id="written-by-jeff">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#written-by-jeff">#</doc-anchor-trigger>
        <span>Written by Jeff</span>
    </h4>
</doc-anchor-target>
<p>My goal was to make a somehow unique implementation, no matter how much it sucked. As a result, I started experimenting with linear search, that is, going through every export and comparing its name with the function I&#x27;m looking for. This was a lot slower than the original function, as it has the time complexity of O(n) at worst, where <code v-pre>n</code> is the total number of exported functions in a PE file.</p>
<p>Later on, I noticed that the exports in some DLLs are alphabetically sorted, which led me to think of <a href="https://www.youtube.co/watch?v=P3YID7liBug">binary searching</a> the array of exported functions. The beauty and elegance of binary search is that you only need to go through O(log n) exported entries at worst. Since <code v-pre>ntdll.dll</code> has 1910 functions that are exported by name (at the time of writing), I only needed 11 iterations at worst case. That, compared to linear search, is really fucking fast.</p>
<p>This implementation has a drawback, however. The exported functions located in the export directory need to be sorted in alphabetical order for binary search to function properly. While <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-edata-section-image-only">the MSDN page for the PE format</a> states that this is intentional, this is not guaranteed. A simple <a href="https://docs.microsoft.com/en-us/cpp/build/reference/module-definition-dot-def-files?view=msvc-170"><code v-pre>.def</code> file</a> during compilation of a DLL can cause the exported functions to become unsorted, and thus, any such DLL would have to resort to using a brute force search.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">/* 
    /favor:AMD64 /arch:AVX2
    Written by Jeff
*/
PVOID GetProcAddress_BinarySearch(PVOID base, const char* func) {
	PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)base;
	PIMAGE_FILE_HEADER head = (PIMAGE_FILE_HEADER)((char*)base + dos-&gt;e_lfanew + sizeof(DWORD));
	PIMAGE_OPTIONAL_HEADER opt_head = (PIMAGE_OPTIONAL_HEADER)(head + 1);
	ULONG export_size = opt_head-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
	ULONG export_rva = opt_head-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

	if (!export_size)
		return NULL;

	PIMAGE_EXPORT_DIRECTORY exports = (PIMAGE_EXPORT_DIRECTORY)((char*)base + export_rva);

	DWORD* name_rva = (PDWORD)((char*)base + exports-&gt;AddressOfNames);

	DWORD* function_rva = (PDWORD)((char*)base + exports-&gt;AddressOfFunctions);

	WORD* ordinal = (PWORD)((char*)base + exports-&gt;AddressOfNameOrdinals);


	// binary search

	unsigned long right, left, middle;
	right = exports-&gt;NumberOfNames;
	left = 0;

	while (right != left) {
		middle = left + ((right - left) &gt;&gt; 1);

		int result = strcmp((char*)base + name_rva[middle], func);
		if (!result)
			return (PVOID)((char*)base + function_rva[ordinal[middle]]);
		else if (result &lt; 0) {
			left = middle;
		}
		else {
			right = middle;
		}
	}

	return NULL;
}

void BM_BinarySearch(benchmark::State&amp; state)
{
	HMODULE hNtdll = LoadLibraryA(&quot;ntdll.dll&quot;);

	PVOID func = NULL;

	for (auto _ : state)
	{
		for (int i = 0; i &lt; func_names.size(); i++)
		{
			func = GetProcAddress_BinarySearch(hNtdll, func_names[i]);
			if (!func)
			{
				printf(&quot;[-] Failed to find exported function\n&quot;);
				exit(-1);
			}
		}
	}
}
BENCHMARK(BM_BinarySearch);</code></pre>
</doc-codeblock></div>
<doc-anchor-target id="results-4">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#results-4">#</doc-anchor-trigger>
        <span>Results</span>
    </h3>
</doc-anchor-target>
<p><strong>Time Complexity</strong>: O(log n)</p>
<p><strong>Space Complexity</strong>: O(1)</p>
<p><strong>Benchmark Results</strong>: ~= 1348 ns (3x faster than <code v-pre>GetProcAddress</code>)</p>
<doc-anchor-target id="case-6-linker-generated-hash-table">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#case-6-linker-generated-hash-table">#</doc-anchor-trigger>
        <span>Case 6: Linker-Generated Hash Table</span>
    </h2>
</doc-anchor-target>
<doc-anchor-target id="written-by-hypervis0r-4">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#written-by-hypervis0r-4">#</doc-anchor-trigger>
        <span>Written by hypervis0r</span>
    </h4>
</doc-anchor-target>
<p>Finally, after spending a week writing the implementation, I finally wrote the fastest implementation of <code v-pre>GetProcAddress</code>. The main performance issue with generating a hash table at runtime is the memory allocation and hashing. I had a brain blast and realized that if the hash table was included in the PE file itself, I could skip the generation and just directly access the table from the loaded module.</p>
<p>The benchmark tests showed that by utilizing the pre-generated hash table, lookup speeds took an astonishing 400 ns, 11 times faster than stock <code v-pre>GetProcAddress</code>. To accomplish this feat, I wrote a Python script utilizing the <a href="https://github.com/lief-project/LIEF"><code v-pre>LIEF</code></a> library to add a new section to a PE file containing the generated hash table.</p>
<p>Due to the fact that I was writing the hash table to disk in the PE section, I knew that I couldn&#x27;t use regular linked list chaining to handle collisions. I first experimented with open addressing, which means whenever there&#x27;s a hash collision, the new item is simply placed in the next free index. The results turned out to be relatively slow, due to the fact that the search algorithm would have to search through thousands of exports whenever there was a collision. I knew I had to use chaining somehow, and while researching I came across an algorithm used in information theory known as &quot;Suffix Automaton&quot;. In short, it is a data structure used to access substrings of a string. It works using nodes that all point to each other and related substrings. Of course, I&#x27;m not working with strings, but rather chained nodes in a hash table, but the theory still applies.</p>
<p><figure class="content-center">
    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/ce/Suffix_automaton_bold.svg/220px-Suffix_automaton_bold.svg.png" alt="Suffix Automaton" />
    <figcaption class="caption">Suffix Automaton</figcaption>
</figure>
</p>
<p>Whenever there is a hash collision, I simply find the next free index, and save the index in the colliding node, similar to chaining linked lists. These indices form a chain in the same manner as linked lists, however instead of saving addresses to the next node, I save indices. This is great because now we have the benefits of linked list chaining, and we are able to effectively serialize the hash table onto disk. Instead of having to search through thousands of exports with open addressing, we can simply search through 4 colliding nodes in the event of a collision.</p>
<p>Later on, after I had written the implementation for this case, I discovered that <a href="https://blogs.oracle.com/solaris/post/gnu-hash-elf-sections">*nix systems have been doing this for years</a>. The <code v-pre>GNU_HASH</code> section was implemented in 2006 in order to better optimize function resolution using pre-compiled hash tables. The implementation of <code v-pre>GNU_HASH</code> even utilizes the DJB2 hash algorithm as well. Why Microsoft hasn&#x27;t decided to implement something similar is quite surprising to me, seeing as there are very large performance gains. Embedding a pre-compiled hash table would even be backwards-compatible with older software, so I fail to see the reason for not utilizing hash tables for exports.</p>
<p>The Python script to generate the hash table can be found <a href="https://github.com/ph4s3tw0/GetProcAddressCaseStudies">in the GitHub repository</a>.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">/* 
    /favor:AMD64 /arch:AVX2
    Written by hypervis0r
*/
void* GetProcAddress_PreGenHashTable(PVOID pModuleBase, const char* key)
{
	// Get DOS header
	PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;
	if (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)
		return;

	// Get NT headers
	PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-&gt;e_lfanew);
	if (pImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE)
		return;

	/* 
        Get the hash table section
        We just strap the section RVA onto the Architecture data directory
    */
	struct IMAGE_EXPORT_HASH_TABLE_DIRECTORY* pExportHashTable = VA(pModuleBase, pImageNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_ARCHITECTURE].VirtualAddress);
	DWORD hash_table_size = pImageNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_ARCHITECTURE].Size;

    // Get the total number of hash table entries
	DWORD total_entries = hash_table_size / sizeof(struct IMAGE_EXPORT_HASH_TABLE_DIRECTORY);
	struct IMAGE_EXPORT_HASH_TABLE_DIRECTORY* entry = NULL;

    // Get the table index
	uint64_t hash = hash_string_djb2(key);
	DWORD index = hash % total_entries;

    // Retrieve the index entry
	entry = &amp;pExportHashTable[index];

	if (entry-&gt;key == hash) // We got a match
		return VA(pModuleBase, entry-&gt;address);
    else                    // Uh oh, hash collision
	{
		while (entry-&gt;next_index != -1)
		{
			/*
				This is the dirtiest C code I've ever written in my life.
				This bit of code right here is why rust is becoming more popular
			*/
			entry = &amp;pExportHashTable[entry-&gt;next_index % total_entries];
			if (entry-&gt;key == hash)
				return VA(pModuleBase, entry-&gt;address);
		}
	}

	return NULL;
}

void BM_PreGenHashTable(benchmark::State&amp; state)
{
	HMODULE hNtdll = LoadLibraryA(&quot;ntdll_pregen.dll&quot;);

	void* func = NULL;

	for (auto _ : state)
	{
		for (int i = 0; i &lt; func_names.size(); i++)
		{
			func = GetProcAddress_PreGenHashTable(hNtdll, func_names[i]);
			if (!func)
			{
				printf(&quot;[-] Failed to find exported function\n&quot;);
				exit(-1);
			}
		}
	}
}
BENCHMARK(BM_PreGenHashTable);</code></pre>
</doc-codeblock></div>
<doc-anchor-target id="results-5">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#results-5">#</doc-anchor-trigger>
        <span>Results</span>
    </h3>
</doc-anchor-target>
<p><strong>Time Complexity</strong>: O(1) on average; O(n) worst case</p>
<p><strong>Space Complexity</strong>: O(n)</p>
<p><strong>Benchmark Results</strong>: ~= 383 ns (11x faster than <code v-pre>GetProcAddress</code>)</p>
<doc-anchor-target id="conclusion">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#conclusion">#</doc-anchor-trigger>
        <span>Conclusion</span>
    </h2>
</doc-anchor-target>
<p>Clearly there are some better methods to resolve functions rather than exclusively using <code v-pre>GetProcAddress</code>. We are certain that further experimentation can be done to further optimize function resolving, and we leave that as an exercise to the reader. If someone from the Microsoft Windows development team is reading this, hypervis0r is open for hire, so <a href="mailto://hypervis0r@phasetw0.com">hit him up</a>.</p>
<p>All code can be found on the <a href="https://github.com/ph4s3tw0/GetProcAddressCaseStudies">phasetw0 GitHub repository here</a>.</p>
<doc-anchor-target id="references">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#references">#</doc-anchor-trigger>
        <span>References</span>
    </h2>
</doc-anchor-target>
<p><a href="https://github.com/ph4s3tw0/GetProcAddressCaseStudies">GitHub Repository</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">MSDN PE Format</a></p>
<p><a href="https://blog.kowalczyk.info/articles/pefileformat.html">PE File Format; Kowalczyk</a></p>
<p><a href="https://github.com/google/benchmark">Google Benchmark Library</a></p>
<p><a href="https://github.com/lief-project/LIEF">LIEF Library</a></p>




                <!-- Required only on API pages -->
                <doc-toolbar-member-filter-no-results />
            </div>

            
<nav class="flex mt-14">
    <div class="w-1/2">
        <a class="px-5 py-4 h-full flex items-center break-all md:break-normal font-medium text-blue-500 dark:text-blue-400 border border-gray-300 hover:border-gray-400 dark:border-dark-650 dark:hover:border-dark-450 rounded-l-lg transition-colors duration-150 relative hover:z-5" href="/windows-internals/bsod-configuration/">
            <svg xmlns="http://www.w3.org/2000/svg" class="mr-3" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" overflow="visible"><path d="M19 11H7.41l5.29-5.29a.996.996 0 10-1.41-1.41l-7 7a1 1 0 000 1.42l7 7a1.024 1.024 0 001.42-.01.996.996 0 000-1.41L7.41 13H19c.55 0 1-.45 1-1s-.45-1-1-1z" /><path fill="none" d="M0 0h24v24H0z" /></svg>
            <span>
                <span class="block text-xs font-normal text-gray-400 dark:text-dark-400">Previous</span>
                <span class="block mt-1">Configuring the Windows 10 x64 Blue Screen of Death</span>
            </span>
        </a>
    </div>

    <div class="w-1/2">
        <a class="px-5 py-4 -mx-px h-full flex items-center justify-end break-all md:break-normal font-medium text-blue-500 dark:text-blue-400 border border-gray-300 hover:border-gray-400 dark:border-dark-650 dark:hover:border-dark-450 rounded-r-lg transition-colors duration-150 relative hover:z-5" href="/writeups/uiuctf2021_ceo/">
            <span>
                <span class="block text-xs font-normal text-right text-gray-400 dark:text-dark-400">Next</span>
                <span class="block mt-1">UIUCTF 2021 - CEO Writeup</span>
            </span>
            <svg xmlns="http://www.w3.org/2000/svg" class="ml-3" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" overflow="visible"><path d="M19.92 12.38a1 1 0 00-.22-1.09l-7-7a.996.996 0 10-1.41 1.41l5.3 5.3H5c-.55 0-1 .45-1 1s.45 1 1 1h11.59l-5.29 5.29a.996.996 0 000 1.41c.19.2.44.3.7.3s.51-.1.71-.29l7-7c.09-.09.16-.21.21-.33z" /><path fill="none" d="M0 0h24v24H0z" /></svg>
        </a>
    </div>
</nav>


        </main>

        <div class="border-t dark:border-dark-650 pt-6 mb-8">
            <footer class="flex flex-wrap items-center justify-between">
    <div>
        <ul class="flex flex-wrap items-center text-sm">
</ul>

    </div>
    <div class="docs-copyright py-2 text-gray-500 dark:text-dark-350 text-sm leading-relaxed"><p>© Copyright 2022. <a href="https://phasetw0.com/">phasetw0</a> All rights reserved.</p>
</div>
</footer>

        </div>
    </div>
    
    <!-- Rendered if sidebar right is enabled -->
    <!-- Sidebar right skeleton-->
    <div v-cloak class="fixed top-0 bottom-0 right-0 transform translate-x-full bg-white border-gray-200 lg:sticky lg:border-l lg:flex-shrink-0 lg:pt-6 lg:transform-none lg:w-56 lg:z-0 md:w-72 sidebar-right skeleton dark:bg-dark-850 dark:border-dark-650">
        <div class="pl-5">
            <div class="w-32 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
            <div class="w-48 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
            <div class="w-40 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
        </div>
    </div>
    
    <!-- User should be able to hide sidebar right -->
    <doc-sidebar-right v-cloak></doc-sidebar-right>
</div>

        </div>
    </div>

    <doc-search-mobile></doc-search-mobile>
    <doc-back-to-top></doc-back-to-top>
</div>


        <div id="docs-overlay-target"></div>

        <script>window.__DOCS__ = { "title": "Optimizing Windows Function Resolving: A Case Study Into GetProcAddress", icon: "file", hasPrism: true, hasMermaid: false, hasMath: false }</script>
    </body>
</html>
